import py_compile
import os
import re
import sys
from typing import Dict, Any, List, Tuple, Optional
import traceback


class EgoError(Exception):
    def __init__(self, message, line_number=None):
        self.message = message
        self.line_number = line_number
        super().__init__(f"Line {line_number}: {message}" if line_number else message)


class Variable:
    def __init__(self, value, type_name, visibility="public", mutability="mutable"):
        self.value = value
        self.type = type_name
        self.visibility = visibility
        self.mutability = mutability
    
    def can_modify(self):
        return self.mutability == "mutable"
    
    def __str__(self):
        return f"{self.visibility} {self.mutability} {self.type} = {self.value}"


class Scope:
    def __init__(self, parent=None, name="global"):
        self.vars = {}
        self.parent = parent
        self.name = name
        self.functions = {}
        
    def get(self, name):
        if name in self.vars:
            return self.vars[name]
        elif self.parent:
            return self.parent.get(name)
        return None
    
    def get_function(self, name):
        if name in self.functions:
            return self.functions[name]
        elif self.parent:
            return self.parent.get_function(name)
        return None
        
    def declare(self, name, value, type_name, visibility, mutability):
        if name in self.vars and not self.vars[name].can_modify():
            raise EgoError(f"Cannot redeclare immutable variable '{name}'")
                
        var = Variable(value, type_name, visibility, mutability)
        self.vars[name] = var
        return var
    
    def declare_function(self, name, params, body, visibility):
        self.functions[name] = {
            "params": params,
            "body": body,
            "visibility": visibility
        }
        
    def update(self, name, value):
        if name in self.vars:
            var = self.vars[name]
            if not var.can_modify():
                raise EgoError(f"Cannot modify immutable variable '{name}'")
            
            var.value = value
            return var
        
        elif self.parent:
            return self.parent.update(name, value)
            
        raise EgoError(f"Variable '{name}' is not defined")


class EgoJITCompiler:
    TYPES = ["int", "float", "string", "bool", "list", "dict", "any"]
    VISIBILITIES = ["public", "private", "protected"]
    MUTABILITIES = ["mutable", "immutable", "const"]
    KEYWORDS = ["if", "else", "for", "while", "function", "return", "import", "from", "class"]
    
    def __init__(self, debug=False):
        self.global_scope = Scope()
        self.current_scope = self.global_scope
        self.debug = debug
        self.line_map = {}
        self.imported_modules = {}
        self.indentation = 0
        
    def parse(self, code, filename="<source>"):
        self.global_scope = Scope()
        self.current_scope = self.global_scope
        self.filename = filename
        
        python_code = [
            "# Generated by EgoJITCompiler",
            "import sys",
            "from ego_stdlib import *"
        ]
        
        original_lines = code.split('\n')
        self.create_line_mapping(original_lines)
        
        clean_code = self._clean(code)
        blocks = self._split_blocks(clean_code)
        
        for i, block in enumerate(blocks):
            try:
                result = self._translate(block)
                if result:
                    if isinstance(result, list):
                        python_code.extend(result)
                    else:
                        python_code.append(result)
            except EgoError as e:
                line_num = self.get_line_number(block)
                error_msg = f"# Error (Line {line_num}): {str(e)}"
                python_code.append(error_msg)
                if self.debug:
                    print(error_msg)
        
        return "\n".join(python_code)
    
    def create_line_mapping(self, lines):
        position = 0
        for i, line in enumerate(lines):
            line_len = len(line) + 1
            for j in range(line_len):
                self.line_map[position + j] = i + 1
            position += line_len
    
    def get_line_number(self, snippet):
        try:
            for pos, line_num in self.line_map.items():
                if pos <= len(snippet):
                    return line_num
        except:
            pass
        return "unknown"
        
    def _clean(self, code):
        code = re.sub(r'//.*$', '', code, flags=re.MULTILINE)
        code = re.sub(r'/\*[\s\S]*?\*/', '', code)
        code = code.replace('\r\n', '\n').replace('\r', '\n')
        
        lines = []
        for line in code.split('\n'):
            content = line.strip()
            if content:
                lines.append(content)
        
        return '\n'.join(lines)

    def _split_blocks(self, code):
        blocks = []
        current = ""
        
        brace_count = 0
        in_string = False
        string_char = None
        escape = False
        
        for char in code:
            current += char
            
            if char in ['"', "'"] and not escape:
                if not in_string:
                    in_string = True
                    string_char = char
                elif string_char == char:
                    in_string = False
                    
            if char == '\\' and in_string and not escape:
                escape = True
            else:
                escape = False
                
            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    
                if char == ';' and brace_count == 0:
                    blocks.append(current.strip())
                    current = ""
        
        if current.strip():
            blocks.append(current.strip())
            
        return blocks
        
    def _translate(self, block):
        block = block.strip()
        
        if block.endswith(';'):
            block = block[:-1].strip()
            
        if not block:
            return ""
        
        if '@py:' in block:
            return self._translate_embedded_python(block)
            
        if self._is_import(block):
            return self._translate_import(block)
        elif self._is_var_decl(block):
            return self._translate_var(block)
        elif self._is_func_decl(block):
            return self._translate_func(block)
        elif self._is_class_decl(block):
            return self._translate_class(block)
        elif self._is_if(block):
            return self._translate_if(block)
        elif self._is_loop(block):
            return self._translate_loop(block)
        elif self._is_print(block):
            return self._translate_print(block)
        elif self._is_return(block):
            return self._translate_return(block)
        elif self._is_func_call(block):
            return self._translate_func_call(block)
        elif self._is_assign(block):
            return self._translate_assign(block)
        else:
            return f"# Unrecognized: {block}"
    
    def _is_import(self, block):
        return block.startswith('import') or block.startswith('from')
    
    def _translate_import(self, block):
        if block.startswith('import'):
            match = re.match(r'import\s+(\w+)(?:\s+as\s+(\w+))?', block)
            if match:
                module_name, alias = match.groups()
                if alias:
                    return f"import {module_name} as {alias}"
                else:
                    return f"import {module_name}"
        else:
            match = re.match(r'from\s+(\w+)\s+import\s+([\w\s,]+)', block)
            if match:
                module_name, imports = match.groups()
                return f"from {module_name} import {imports}"
        
        raise EgoError(f"Invalid import syntax: {block}")
    
    def _is_embedded_python(self, block):
        return '@py:' in block
    
    def _translate_embedded_python(self, block):
        python_code = block.split('@py:', 1)[1].strip()
        return python_code
            
    def _is_var_decl(self, block):
        pattern = r'^(public|private|protected)\s+(mutable|immutable|const)\s+\w+\s+\w+\s*=.*$'
        return bool(re.match(pattern, block))
            
    def _translate_var(self, block):
        parts = block.split('=', 1)
        declaration = parts[0].strip().split()
        value = parts[1].strip() if len(parts) > 1 else None
        
        if len(declaration) < 4:
            raise EgoError(f"Invalid variable declaration: {block}")
        
        visibility = declaration[0]
        mutability = declaration[1]
        type_name = declaration[2]
        var_name = declaration[3]
        
        if visibility not in self.VISIBILITIES:
            raise EgoError(f"Invalid visibility: {visibility}")
            
        if mutability not in self.MUTABILITIES:
            raise EgoError(f"Invalid mutability: {mutability}")
            
        if type_name not in self.TYPES:
            raise EgoError(f"Invalid type: {type_name}")
        
        if value is None:
            if type_name == "int":
                value = "0"
            elif type_name == "float":
                value = "0.0"
            elif type_name == "string":
                value = '""'
            elif type_name == "bool":
                value = "False"
            elif type_name == "list":
                value = "[]"
            elif type_name == "dict":
                value = "{}"
            else:
                value = "None"
            
        self.current_scope.declare(var_name, value, type_name, visibility, mutability)
        
        py_value = self._convert_value(value, type_name)
        
        type_check = ""
        if self.debug and type_name != "any":
            type_map = {
                "int": "int", 
                "float": "float", 
                "string": "str", 
                "bool": "bool",
                "list": "list",
                "dict": "dict"
            }
            py_type = type_map.get(type_name)
            if py_type:
                type_check = f"\nassert isinstance({var_name}, {py_type}), f\"Type error: {var_name} should be {type_name}, got {{type({var_name}).__name__}}\""
        
        result = f"{var_name} = {py_value}{type_check}"
        
        if visibility != "public":
            result = f"# {visibility}\n{result}"
            
        if mutability == "const":
            result = f"{result}\n# {var_name} is a constant and cannot be modified"
            
        return result
        
    def _convert_value(self, value, type_name):
        if type_name == "string" and not (value.startswith('"') or value.startswith("'")):
            return f'"{value}"'
        elif type_name == "bool":
            if value.lower() == "true":
                return "True"
            elif value.lower() == "false":
                return "False"
        elif type_name == "int" and value.strip().isdigit():
            return value
        elif type_name == "float" and re.match(r'^\d+\.\d+$', value.strip()):
            return value
        elif type_name == "list" and value.startswith('[') and value.endswith(']'):
            return value
        elif type_name == "dict" and value.startswith('{') and value.endswith('}'):
            return value
        return value
    
    def _is_class_decl(self, block):
        pattern = r'^(public|private|protected)\s+class\s+\w+\s*\{.*\}$'
        return bool(re.match(pattern, block, re.DOTALL))
    
    def _translate_class(self, block):
        match = re.match(r'^(public|private|protected)\s+class\s+(\w+)(?:\s+extends\s+(\w+))?\s*\{(.*)\}$', block, re.DOTALL)
        if not match:
            raise EgoError("Invalid class syntax")
            
        visibility, name, parent, body = match.groups()
        parent = parent or "object"
        
        old_scope = self.current_scope
        class_scope = Scope(old_scope, name=name)
        self.current_scope = class_scope
        
        methods = []
        body_blocks = self._split_blocks(body)
        
        for method_block in body_blocks:
            if method_block.strip():
                if self._is_func_decl(method_block):
                    method_code = self._translate_func(method_block, is_method=True)
                    methods.append(method_code)
                elif self._is_var_decl(method_block):
                    var_code = self._translate_var(method_block)
                    methods.append(f"    {var_code}")
        
        self.current_scope = old_scope
        
        result = [f"class {name}({parent}):"]
        
        if not methods:
            result.append("    pass")
        else:
            result.extend(methods)
            
        return "\n".join(result)
        
    def _is_func_decl(self, block):
        pattern = r'^(public|private|protected)\s+function\s+\w+\s*\(.*\)\s*\{.*\}$'
        return bool(re.match(pattern, block, re.DOTALL))
        
    def _translate_func(self, block, is_method=False):
        match = re.match(r'^(public|private|protected)\s+function\s+(\w+)\s*\((.*)\)(?:\s*:\s*(\w+))?\s*\{(.*)\}$', block, re.DOTALL)
        if not match:
            raise EgoError("Invalid function syntax")
            
        visibility, name, params_str, return_type, body = match.groups()
        
        params = []
        param_vars = []
        
        if params_str.strip():
            for param in params_str.split(','):
                param = param.strip()
                if param:
                    param_parts = param.split()
                    if len(param_parts) >= 2:
                        param_type = param_parts[-2]
                        param_name = param_parts[-1]
                        params.append(param_name)
                        param_vars.append((param_name, param_type))
        
        old_scope = self.current_scope
        func_scope = Scope(old_scope, name=name)
        self.current_scope = func_scope
        
        for param_name, param_type in param_vars:
            self.current_scope.declare(param_name, param_name, param_type, "private", "mutable")
        
        body_lines = []
        body_blocks = self._split_blocks(body)
        
        for line_block in body_blocks:
            if line_block.strip():
                translated = self._translate(line_block)
                if translated:
                    if isinstance(translated, list):
                        for t_line in translated:
                            body_lines.append(f"    {t_line}")
                    else:
                        body_lines.append(f"    {translated}")
        
        if self.debug and param_vars:
            type_checks = []
            for param_name, param_type in param_vars:
                if param_type in self.TYPES and param_type != "any":
                    type_map = {
                        "int": "int", 
                        "float": "float", 
                        "string": "str", 
                        "bool": "bool",
                        "list": "list",
                        "dict": "dict"
                    }
                    py_type = type_map.get(param_type)
                    if py_type:
                        check = f"assert isinstance({param_name}, {py_type}), f\"Type error: Parameter {param_name} should be {param_type}, got {{type({param_name}).__name__}}\""
                        type_checks.append(f"    {check}")
            
            if type_checks:
                body_lines = type_checks + body_lines
        
        self.current_scope = old_scope
        
        self.current_scope.declare_function(name, param_vars, body, visibility)
        
        method_prefix = "def " if not is_method else "def "
        if is_method and name != "__init__":
            if "self" not in params:
                params.insert(0, "self")
        elif is_method and name == "__init__":
            if "self" not in params:
                params.insert(0, "self")
                
        func_def = f"{method_prefix}{name}({', '.join(params)}):"
        
        if return_type:
            body_lines.insert(0, f'    """{name} -> {return_type}"""')
        
        if not body_lines:
            body_lines.append("    pass")
            
        result = [func_def] + body_lines
        
        return "\n".join(result)
    
    def _is_return(self, block):
        return block.startswith('return')
    
    def _translate_return(self, block):
        match = re.match(r'return(?:\s+(.*))?', block)
        if not match:
            raise EgoError("Invalid return statement")
            
        value = match.group(1)
        if value:
            return f"return {value.strip()}"
        else:
            return "return None"
        
    def _is_if(self, block):
        return block.startswith('if')
        
    def _translate_if(self, block):
        match = re.match(r'if\s*\((.*)\)\s*\{(.*)\}(?:\s*else\s*\{(.*)\})?', block, re.DOTALL)
        if not match:
            raise EgoError("Invalid if statement syntax")
            
        condition, if_body, else_body = match.groups()
        
        condition = condition.replace('==', '==').replace('!=', '!=')
        condition = condition.replace('&&', 'and').replace('||', 'or')
        
        if_lines = []
        if_blocks = self._split_blocks(if_body)
        for line_block in if_blocks:
            if line_block.strip():
                translated = self._translate(line_block)
                if translated:
                    if isinstance(translated, list):
                        for t_line in translated:
                            if_lines.append(f"    {t_line}")
                    else:
                        if_lines.append(f"    {translated}")
        
        result = [f"if {condition}:"]
        
        if not if_lines:
            if_lines.append("    pass")
            
        result.extend(if_lines)
        
        if else_body:
            else_lines = []
            else_blocks = self._split_blocks(else_body)
            for line_block in else_blocks:
                if line_block.strip():
                    translated = self._translate(line_block)
                    if translated:
                        if isinstance(translated, list):
                            for t_line in translated:
                                else_lines.append(f"    {t_line}")
                        else:
                            else_lines.append(f"    {translated}")
            
            result.append("else:")
            
            if not else_lines:
                else_lines.append("    pass")
                
            result.extend(else_lines)
        
        return result
        
    def _is_loop(self, block):
        return block.startswith('for') or block.startswith('while')
        
    def _translate_loop(self, block):
        if block.startswith('for'):
            match = re.match(r'for\s*\((.*);(.*);(.*)\)\s*\{(.*)\}', block, re.DOTALL)
            if not match:
                match = re.match(r'for\s*\((.*)\s+in\s+(.*)\)\s*\{(.*)\}', block, re.DOTALL)
                if match:
                    var, iterable, body = match.groups()
                    
                    old_scope = self.current_scope
                    loop_scope = Scope(old_scope, name="for_loop")
                    self.current_scope = loop_scope
                    
                    body_lines = []
                    body_blocks = self._split_blocks(body)
                    
                    for line_block in body_blocks:
                        if line_block.strip():
                            translated = self._translate(line_block)
                            if translated:
                                if isinstance(translated, list):
                                    for t_line in translated:
                                        body_lines.append(f"    {t_line}")
                                else:
                                    body_lines.append(f"    {translated}")
                    
                    self.current_scope = old_scope
                    
                    result = [f"for {var} in {iterable}:"]
                    
                    if not body_lines:
                        body_lines.append("    pass")
                        
                    result.extend(body_lines)
                    
                    return result
                else:
                    raise EgoError("Invalid for loop syntax")
                
            init, cond, update, body = match.groups()
            
            old_scope = self.current_scope
            loop_scope = Scope(old_scope, name="for_loop")
            self.current_scope = loop_scope
            
            init_code = self._translate(init)
            cond_code = cond.strip().replace('&&', 'and').replace('||', 'or')
            update_code = self._translate(update)
            
            body_lines = []
            body_blocks = self._split_blocks(body)
            
            for line_block in body_blocks:
                if line_block.strip():
                    translated = self._translate(line_block)
                    if translated:
                        if isinstance(translated, list):
                            for t_line in translated:
                                body_lines.append(f"    {t_line}")
                        else:
                            body_lines.append(f"    {translated}")
            
            if update_code:
                body_lines.append(f"    {update_code}")
            
            self.current_scope = old_scope
            
            result = []
            if init_code:
                result.append(init_code)
            result.append(f"while {cond_code}:")
            
            if not body_lines:
                body_lines.append("    pass")
                
            result.extend(body_lines)
            
            return result
        else:
            match = re.match(r'while\s*\((.*)\)\s*\{(.*)\}', block, re.DOTALL)
            if not match:
                raise EgoError("Invalid while loop syntax")
                
            condition, body = match.groups()
            condition = condition.replace('&&', 'and').replace('||', 'or')
            
            old_scope = self.current_scope
            loop_scope = Scope(old_scope, name="while_loop")
            self.current_scope = loop_scope
            
            body_lines = []
            body_blocks = self._split_blocks(body)
            
            for line_block in body_blocks:
                if line_block.strip():
                    translated = self._translate(line_block)
                    if translated:
                        if isinstance(translated, list):
                            for t_line in translated:
                                body_lines.append(f"    {t_line}")
                        else:
                            body_lines.append(f"    {translated}")
            
            self.current_scope = old_scope
            
            result = [f"while {condition}:"]
            
            if not body_lines:
                body_lines.append("    pass")
                
            result.extend(body_lines)
            
            return result
    
    def _is_func_call(self, block):
        return re.match(r'^\w+\s*\(.*\)$', block) is not None
    
    def _translate_func_call(self, block):
        match = re.match(r'^(\w+)\s*\((.*)\)$', block)
        if not match:
            raise EgoError("Invalid function call syntax")
            
        func_name, args = match.groups()
        
        func_info = self.current_scope.get_function(func_name)
        if not func_info and not func_name in ['print', 'len', 'int', 'float', 'str', 'bool', 'list', 'dict']:
            if self.debug:
                return f"# WARNING: Function '{func_name}' not defined in this scope\n{block}"
        
        return block
        
    def _is_print(self, block):
        return block.startswith('print')
        
    def _translate_print(self, block):
        match = re.match(r'print\s*\((.*)\)', block)
        if not match:
            raise EgoError("Invalid print statement")
            
        arg = match.group(1).strip()
        
        args = []
        for a in re.split(r',\s*', arg):
            a = a.strip()
            if not (a.startswith('"') or a.startswith("'") or a.isdigit() or 
                    a in ['True', 'False'] or re.match(r'^\d+\.\d+$', a)):
                var = self.current_scope.get(a)
                if not var and not a.startswith('f"'):
                    if self.debug:
                        return f"# WARNING: Variable '{a}' not defined\nprint({arg})"
            args.append(a)
            
        return f"print({', '.join(args)})"
        
    def _is_assign(self, block):
        return '=' in block and not self._is_var_decl(block) and not self._is_compare(block)
    
    def _is_compare(self, block):
        return '==' in block and not re.search(r'=\s*==', block)
        
    def _translate_assign(self, block):
        parts = block.split('=', 1)
        var_name = parts[0].strip()
        value = parts[1].strip()
        
        var = self.current_scope.get(var_name)
        if not var:
            if self.debug:
                return f"# WARNING: Variable '{var_name}' not defined\n{var_name} = {value}"
            else:
                return f"{var_name} = {value}"
            
        if not var.can_modify():
            raise EgoError(f"Cannot modify immutable variable '{var_name}'")
            
        self.current_scope.update(var_name, value)
        
        return f"{var_name} = {value}"
    
    def compile(self, ego_code, output_file):
        python_code = self.parse(ego_code)
        temp_file = 'temp_ego_code.py'
        
        with open(temp_file, 'w') as f:
            f.write(python_code)
        
        try:
            py_compile.compile(temp_file, cfile=output_file)
            os.remove(temp_file)
            print(f"Compiled successfully to '{output_file}'")
        except py_compile.PyCompileError as e:
            print(f"Compilation failed: {e}")
            os.remove(temp_file)


compiler = EgoJITCompiler()
sample_code = """





"""
compiler.compile(sample_code, 'pkg_strconfig_sizeof.ego')
