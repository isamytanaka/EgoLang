import py_compile
import os
import re
import sys
from typing import Dict, Any, List, Tuple, Optional
import traceback


class EgoError(Exception):
    def __init__(self, message, line_number=None):
        self.message = message
        self.line_number = line_number
        super().__init__(f"Line {line_number}: {message}" if line_number else message)


class Variable:
    def __init__(self, value, mutability="rigid"):
        self.value = value
        self.mutability = mutability
    
    def can_modify(self):
        return self.mutability == "fluid"
    
    def __str__(self):
        return f"{self.mutability} = {self.value}"


class Scope:
    def __init__(self, parent=None, name="root"):
        self.vars = {}
        self.parent = parent
        self.name = name
        
    def get(self, name):
        if name in self.vars:
            return self.vars[name]
        elif self.parent:
            return self.parent.get(name)
        return None
        
    def declare(self, name, value, mutability):
        if name in self.vars and not self.vars[name].can_modify():
            raise EgoError(f"Cannot redeclare rigid variable '{name}'")
                
        var = Variable(value, mutability)
        self.vars[name] = var
        return var
    
    def update(self, name, value):
        if name in self.vars:
            var = self.vars[name]
            if not var.can_modify():
                raise EgoError(f"Cannot modify rigid variable '{name}'")
            
            var.value = value
            return var
        
        elif self.parent:
            return self.parent.update(name, value)
            
        raise EgoError(f"Variable '{name}' has not been declared")


class EgoCompiler:
    MUTABILITIES = ["fluid", "rigid"]
    KEYWORDS = ["say", "when", "otherwise", "execute", "with", "is", "not", "and", "or"]
    
    def __init__(self, debug=False):
        self.global_scope = Scope()
        self.current_scope = self.global_scope
        self.debug = debug
        self.line_map = {}
        
    def parse(self, code, filename="<source>"):
        self.global_scope = Scope()
        self.current_scope = self.global_scope
        self.filename = filename
        
        python_code = [
            "# Generated by EgoCompiler v2.10.1",
            "import sys",
            "from ego_stdlib import *"
        ]
        
        original_lines = code.split('\n')
        self.create_line_mapping(original_lines)
        
        clean_code = self._clean(code)
        blocks = self._split_blocks(clean_code)
        
        for i, block in enumerate(blocks):
            try:
                result = self._translate(block)
                if result:
                    if isinstance(result, list):
                        python_code.extend(result)
                    else:
                        python_code.append(result)
            except EgoError as e:
                line_num = self.get_line_number(block)
                error_msg = f"# Error (Line {line_num}): {str(e)}"
                python_code.append(error_msg)
                if self.debug:
                    print(error_msg)
        
        return "\n".join(python_code)
    
    def create_line_mapping(self, lines):
        position = 0
        for i, line in enumerate(lines):
            line_len = len(line) + 1
            for j in range(line_len):
                self.line_map[position + j] = i + 1
            position += line_len
    
    def get_line_number(self, snippet):
        try:
            for pos, line_num in self.line_map.items():
                if pos <= len(snippet):
                    return line_num
        except:
            pass
        return "unknown"
        
    def _clean(self, code):
        # No comment cleaning as comments are not supported in EgoLang 2.10.1
        code = code.replace('\r\n', '\n').replace('\r', '\n')
        
        lines = []
        for line in code.split('\n'):
            content = line.strip()
            if content:
                lines.append(content)
        
        return '\n'.join(lines)

    def _split_blocks(self, code):
        blocks = []
        current = ""
        
        brace_count = 0
        in_string = False
        string_char = None
        escape = False
        
        for char in code:
            current += char
            
            if char in ['"', "'"] and not escape:
                if not in_string:
                    in_string = True
                    string_char = char
                elif string_char == char:
                    in_string = False
                    
            if char == '\\' and in_string and not escape:
                escape = True
            else:
                escape = False
                
            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    
                if char == '.' and brace_count == 0:
                    blocks.append(current.strip())
                    current = ""
        
        if current.strip():
            blocks.append(current.strip())
            
        return blocks
        
    def _translate(self, block):
        block = block.strip()
        
        if block.endswith('.'):
            block = block[:-1].strip()
            
        if not block:
            return ""
            
        if self._is_var_decl(block):
            return self._translate_var(block)
        elif self._is_when(block):
            return self._translate_when(block)
        elif self._is_say(block):
            return self._translate_say(block)
        elif self._is_execute(block):
            return self._translate_execute(block)
        elif self._is_assign(block):
            return self._translate_assign(block)
        else:
            return f"# Unrecognized: {block}"
            
    def _is_var_decl(self, block):
        pattern = r'^(fluid|rigid)\s+(\w+)\s+is\s+(.+)$'
        return bool(re.match(pattern, block))
            
    def _translate_var(self, block):
        match = re.match(r'^(fluid|rigid)\s+(\w+)\s+is\s+(.+)$', block)
        if not match:
            raise EgoError(f"Invalid variable declaration: {block}")
        
        mutability, var_name, value = match.groups()
        
        if mutability not in self.MUTABILITIES:
            raise EgoError(f"Invalid mutability: {mutability}")
            
        self.current_scope.declare(var_name, value, mutability)
        
        py_value = value
        if not (value.startswith('"') or value.startswith("'") or 
                value.isdigit() or value in ['True', 'False'] or 
                re.match(r'^\d+\.\d+$', value)):
            # Simple automatic type conversion
            if value.lower() == "true":
                py_value = "True"
            elif value.lower() == "false":
                py_value = "False"
            elif value.isdigit():
                py_value = value
            elif re.match(r'^\d+\.\d+$', value):
                py_value = value
            else:
                py_value = f'"{value}"'
        
        result = f"{var_name} = {py_value}"
        
        return result
        
    def _is_when(self, block):
        return block.startswith('when')
        
    def _translate_when(self, block):
        match = re.match(r'when\s+\((.*)\)\s+\{(.*)\}(?:\s+otherwise\s+\{(.*)\})?', block, re.DOTALL)
        if not match:
            raise EgoError("Invalid when statement syntax")
            
        condition, if_body, else_body = match.groups()
        
        # Replace Ego operators with Python equivalents
        condition = condition.replace(' is ', ' == ').replace(' not ', ' != ')
        condition = condition.replace(' and ', ' and ').replace(' or ', ' or ')
        
        if_lines = []
        if_blocks = self._split_blocks(if_body)
        for line_block in if_blocks:
            if line_block.strip():
                translated = self._translate(line_block)
                if translated:
                    if isinstance(translated, list):
                        for t_line in translated:
                            if_lines.append(f"    {t_line}")
                    else:
                        if_lines.append(f"    {translated}")
        
        result = [f"if {condition}:"]
        
        if not if_lines:
            if_lines.append("    pass")
            
        result.extend(if_lines)
        
        if else_body:
            else_lines = []
            else_blocks = self._split_blocks(else_body)
            for line_block in else_blocks:
                if line_block.strip():
                    translated = self._translate(line_block)
                    if translated:
                        if isinstance(translated, list):
                            for t_line in translated:
                                else_lines.append(f"    {t_line}")
                        else:
                            else_lines.append(f"    {translated}")
            
            result.append("else:")
            
            if not else_lines:
                else_lines.append("    pass")
                
            result.extend(else_lines)
        
        return result
        
    def _is_say(self, block):
        return block.startswith('say')
        
    def _translate_say(self, block):
        match = re.match(r'say\s+\((.*)\)', block)
        if not match:
            raise EgoError("Invalid say statement")
            
        arg = match.group(1).strip()
        
        args = []
        for a in re.split(r',\s*', arg):
            a = a.strip()
            if not (a.startswith('"') or a.startswith("'") or a.isdigit() or 
                    a in ['True', 'False'] or re.match(r'^\d+\.\d+$', a)):
                var = self.current_scope.get(a)
                if not var and not a.startswith('f"'):
                    if self.debug:
                        return f"# WARNING: Variable '{a}' not defined\nprint({arg})"
            args.append(a)
            
        return f"print({', '.join(args)})"
    
    def _is_execute(self, block):
        return block.startswith('execute')
    
    def _translate_execute(self, block):
        match = re.match(r'execute\s+(\w+)\s+with\s+\((.*)\)', block)
        if not match:
            raise EgoError("Invalid execute statement")
            
        func_name, args = match.groups()
        
        # Map some EgoLang functions to Python equivalents
        func_map = {
            "length": "len",
            "type": "type",
            "number": "int",
            "text": "str",
            "decimal": "float",
            "logic": "bool"
        }
        
        py_func = func_map.get(func_name, func_name)
        
        return f"{py_func}({args})"
        
    def _is_assign(self, block):
        return 'becomes' in block
        
    def _translate_assign(self, block):
        parts = block.split('becomes', 1)
        var_name = parts[0].strip()
        value = parts[1].strip()
        
        var = self.current_scope.get(var_name)
        if not var:
            if self.debug:
                return f"# WARNING: Variable '{var_name}' not defined\n{var_name} = {value}"
            else:
                return f"{var_name} = {value}"
            
        if not var.can_modify():
            raise EgoError(f"Cannot modify rigid variable '{var_name}'")
            
        self.current_scope.update(var_name, value)
        
        return f"{var_name} = {value}"
    
    def compile(self, ego_code, output_file):
        python_code = self.parse(ego_code)
        temp_file = 'temp_ego_code.py'
        
        with open(temp_file, 'w') as f:
            f.write(python_code)
        
        try:
            py_compile.compile(temp_file, cfile=output_file)
            os.remove(temp_file)
            print(f"Compiled successfully to '{output_file}'")
        except py_compile.PyCompileError as e:
            print(f"Compilation failed: {e}")
            os.remove(temp_file)


# Create stdlib file with minimal functions
with open('ego_stdlib.py', 'w') as f:
    f.write("""
# EgoLang 2.10.1 Standard Library
def input_value(prompt):
    return input(prompt)
    
def to_number(value):
    return int(value)
    
def to_decimal(value):
    return float(value)
    
def to_text(value):
    return str(value)
""")

compiler = EgoCompiler()
sample_code = """
fluid greeting is "Hello, EgoLang 2.10.1!".
rigid max_count is 5.
fluid current is 1.

when (current <= max_count) {
    say(greeting).
    say("Count:", current).
    current becomes current + 1.
} otherwise {
    say("Finished counting to", max_count).
}.

say("Program complete").
"""

compiler.compile(sample_code, 'ego_program.ego')
