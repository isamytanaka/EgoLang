import py_compile
import os
import re
import sys
from typing import Dict, Any, List, Tuple, Optional
import traceback


class EgoError(Exception):
    def __init__(self, message, line_number=None):
        self.message = message
        self.line_number = line_number
        super().__init__(f"Line {line_number}: {message}" if line_number else message)


class Symbol:
    def __init__(self, value, qualifier, storage, lifecycle):
        self.value = value
        self.qualifier = qualifier  # numeric, logical, textual, composite, abstract
        self.storage = storage      # transient, persistent, volatile
        self.lifecycle = lifecycle  # ephemeral, enduring, permanent
    
    def can_transform(self):
        return self.lifecycle != "permanent"
    
    def __str__(self):
        return f"{self.storage} {self.lifecycle} {self.qualifier} = {self.value}"


class Domain:
    def __init__(self, parent=None, identifier="root"):
        self.symbols = {}
        self.parent = parent
        self.identifier = identifier
        self.procedures = {}
        
    def resolve(self, identifier):
        if identifier in self.symbols:
            return self.symbols[identifier]
        elif self.parent:
            return self.parent.resolve(identifier)
        return None
    
    def resolve_procedure(self, identifier):
        if identifier in self.procedures:
            return self.procedures[identifier]
        elif self.parent:
            return self.parent.resolve_procedure(identifier)
        return None
        
    def bind(self, identifier, value, qualifier, storage, lifecycle):
        if identifier in self.symbols and not self.symbols[identifier].can_transform():
            raise EgoError(f"Cannot rebind permanent symbol '{identifier}'")
                
        symbol = Symbol(value, qualifier, storage, lifecycle)
        self.symbols[identifier] = symbol
        return symbol
    
    def register_procedure(self, identifier, inputs, operations, accessor):
        self.procedures[identifier] = {
            "inputs": inputs,
            "operations": operations,
            "accessor": accessor
        }
        
    def transform(self, identifier, value):
        if identifier in self.symbols:
            symbol = self.symbols[identifier]
            if not symbol.can_transform():
                raise EgoError(f"Cannot transform permanent symbol '{identifier}'")
            
            symbol.value = value
            return symbol
        
        elif self.parent:
            return self.parent.transform(identifier, value)
            
        raise EgoError(f"Symbol '{identifier}' is not bound in this domain")


class EgoJITCompiler:
    QUALIFIERS = ["numeric", "logical", "textual", "composite", "abstract"]
    STORAGES = ["transient", "persistent", "volatile"]
    LIFECYCLES = ["ephemeral", "enduring", "permanent"]
    DIRECTIVES = ["include", "elevate", "embed", "pragma", "assert"]
    
    def __init__(self, debug=False):
        self.root_domain = Domain()
        self.current_domain = self.root_domain
        self.debug = debug
        self.line_map = {}
        self.included_modules = {}
        self.abstraction_level = 0
        
    def parse(self, code, filename="<origin>"):
        self.root_domain = Domain()
        self.current_domain = self.root_domain
        self.filename = filename
        
        machine_code = [
            "# Generated by EgoJITCompiler v2.9",
            "import sys",
            "from ego_abstraction_layer import *"
        ]
        
        original_lines = code.split('\n')
        self.create_line_mapping(original_lines)
        
        clean_code = self._purify(code)
        contexts = self._partition_contexts(clean_code)
        
        for i, context in enumerate(contexts):
            try:
                result = self._transmute(context)
                if result:
                    if isinstance(result, list):
                        machine_code.extend(result)
                    else:
                        machine_code.append(result)
            except EgoError as e:
                line_num = self.get_line_number(context)
                error_msg = f"# Error (Line {line_num}): {str(e)}"
                machine_code.append(error_msg)
                if self.debug:
                    print(error_msg)
        
        return "\n".join(machine_code)
    
    def create_line_mapping(self, lines):
        position = 0
        for i, line in enumerate(lines):
            line_len = len(line) + 1
            for j in range(line_len):
                self.line_map[position + j] = i + 1
            position += line_len
    
    def get_line_number(self, snippet):
        try:
            for pos, line_num in self.line_map.items():
                if pos <= len(snippet):
                    return line_num
        except:
            pass
        return "unknown"
        
    def _purify(self, code):
        # Remove inline annotations
        code = re.sub(r'--.*$', '', code, flags=re.MULTILINE)
        # Remove block annotations  
        code = re.sub(r'/-[\s\S]*?-/', '', code)
        code = code.replace('\r\n', '\n').replace('\r', '\n')
        
        lines = []
        for line in code.split('\n'):
            content = line.strip()
            if content:
                lines.append(content)
        
        return '\n'.join(lines)

    def _partition_contexts(self, code):
        contexts = []
        current = ""
        
        brace_count = 0
        in_string = False
        string_char = None
        escape = False
        
        for char in code:
            current += char
            
            if char in ['"', "'"] and not escape:
                if not in_string:
                    in_string = True
                    string_char = char
                elif string_char == char:
                    in_string = False
                    
            if char == '\\' and in_string and not escape:
                escape = True
            else:
                escape = False
                
            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    
                if char == '.' and brace_count == 0:
                    contexts.append(current.strip())
                    current = ""
        
        if current.strip():
            contexts.append(current.strip())
            
        return contexts
        
    def _transmute(self, context):
        context = context.strip()
        
        if context.endswith('.'):
            context = context[:-1].strip()
            
        if not context:
            return ""
        
        if '@meta:' in context:
            return self._transmute_meta_directive(context)
            
        if self._is_include(context):
            return self._transmute_include(context)
        elif self._is_symbol_binding(context):
            return self._transmute_symbol(context)
        elif self._is_procedure_def(context):
            return self._transmute_procedure(context)
        elif self._is_block(context):
            return self._transmute_block(context)
        elif self._is_branch(context):
            return self._transmute_branch(context)
        elif self._is_iteration(context):
            return self._transmute_iteration(context)
        elif self._is_emit(context):
            return self._transmute_emit(context)
        elif self._is_yield(context):
            return self._transmute_yield(context)
        elif self._is_procedure_invoke(context):
            return self._transmute_procedure_invoke(context)
        elif self._is_transform(context):
            return self._transmute_transform(context)
        else:
            return f"# Unrecognized context: {context}"
    
    def _is_include(self, context):
        return context.startswith('include') or context.startswith('elevate')
    
    def _transmute_include(self, context):
        if context.startswith('include'):
            match = re.match(r'include\s+(\w+)(?:\s+as\s+(\w+))?', context)
            if match:
                module_name, alias = match.groups()
                if alias:
                    return f"import {module_name} as {alias}"
                else:
                    return f"import {module_name}"
        else:
            match = re.match(r'elevate\s+(\w+)\s+expose\s+([\w\s,]+)', context)
            if match:
                module_name, symbols = match.groups()
                return f"from {module_name} import {symbols}"
        
        raise EgoError(f"Invalid include directive: {context}")
    
    def _is_meta_directive(self, context):
        return '@meta:' in context
    
    def _transmute_meta_directive(self, context):
        meta_code = context.split('@meta:', 1)[1].strip()
        return meta_code
            
    def _is_symbol_binding(self, context):
        pattern = r'^(transient|persistent|volatile)\s+(ephemeral|enduring|permanent)\s+\w+\s+\w+\s*<-.*$'
        return bool(re.match(pattern, context))
            
    def _transmute_symbol(self, context):
        parts = context.split('<-', 1)
        declaration = parts[0].strip().split()
        value = parts[1].strip() if len(parts) > 1 else None
        
        if len(declaration) < 4:
            raise EgoError(f"Invalid symbol binding: {context}")
        
        storage = declaration[0]
        lifecycle = declaration[1]
        qualifier = declaration[2]
        symbol_id = declaration[3]
        
        if storage not in self.STORAGES:
            raise EgoError(f"Invalid storage specifier: {storage}")
            
        if lifecycle not in self.LIFECYCLES:
            raise EgoError(f"Invalid lifecycle specifier: {lifecycle}")
            
        if qualifier not in self.QUALIFIERS:
            raise EgoError(f"Invalid qualifier: {qualifier}")
        
        if value is None:
            if qualifier == "numeric":
                value = "0"
            elif qualifier == "logical":
                value = "False"
            elif qualifier == "textual":
                value = '""'
            elif qualifier == "composite":
                value = "[]"
            elif qualifier == "abstract":
                value = "None"
            
        self.current_domain.bind(symbol_id, value, qualifier, storage, lifecycle)
        
        py_value = self._convert_value(value, qualifier)
        
        type_check = ""
        if self.debug and qualifier != "abstract":
            type_map = {
                "numeric": "int, float", 
                "logical": "bool", 
                "textual": "str", 
                "composite": "list, dict, tuple"
            }
            py_type = type_map.get(qualifier)
            if py_type:
                if ',' in py_type:
                    types = py_type.split(', ')
                    check_parts = [f"isinstance({symbol_id}, {t})" for t in types]
                    check_expr = " or ".join(check_parts)
                    type_check = f"\nassert {check_expr}, f\"Qualifier violation: {symbol_id} should be {qualifier}, got {{type({symbol_id}).__name__}}\""
                else:
                    type_check = f"\nassert isinstance({symbol_id}, {py_type}), f\"Qualifier violation: {symbol_id} should be {qualifier}, got {{type({symbol_id}).__name__}}\""
        
        result = f"{symbol_id} = {py_value}{type_check}"
        
        if storage != "transient":
            result = f"# {storage}\n{result}"
            
        if lifecycle == "permanent":
            result = f"{result}\n# {symbol_id} has permanent lifecycle and cannot be transformed"
            
        return result
        
    def _convert_value(self, value, qualifier):
        if qualifier == "textual" and not (value.startswith('"') or value.startswith("'")):
            return f'"{value}"'
        elif qualifier == "logical":
            if value.lower() == "true":
                return "True"
            elif value.lower() == "false":
                return "False"
        elif qualifier == "numeric" and (value.strip().isdigit() or re.match(r'^\d+\.\d+$', value.strip())):
            return value
        elif qualifier == "composite" and (value.startswith('[') or value.startswith('{')):
            return value
        return value
    
    def _is_block(self, context):
        pattern = r'^block\s+\w+\s*\{.*\}$'
        return bool(re.match(pattern, context, re.DOTALL))
    
    def _transmute_block(self, context):
        match = re.match(r'^block\s+(\w+)(?:\s+extends\s+(\w+))?\s*\{(.*)\}$', context, re.DOTALL)
        if not match:
            raise EgoError("Invalid block syntax")
            
        identifier, parent, body = match.groups()
        
        old_domain = self.current_domain
        block_domain = Domain(old_domain, identifier=identifier)
        self.current_domain = block_domain
        
        code_segments = []
        body_contexts = self._partition_contexts(body)
        
        result = [f"# Block: {identifier}"]
        
        for block_context in body_contexts:
            if block_context.strip():
                translated = self._transmute(block_context)
                if translated:
                    if isinstance(translated, list):
                        result.extend(translated)
                    else:
                        result.append(translated)
        
        self.current_domain = old_domain
        
        return result
        
    def _is_procedure_def(self, context):
        pattern = r'^(transient|persistent|volatile)\s+procedure\s+\w+\s*\[.*\]\s*\{.*\}$'
        return bool(re.match(pattern, context, re.DOTALL))
        
    def _transmute_procedure(self, context):
        match = re.match(r'^(transient|persistent|volatile)\s+procedure\s+(\w+)\s*\[(.*)\](?:\s*:\s*(\w+))?\s*\{(.*)\}$', context, re.DOTALL)
        if not match:
            raise EgoError("Invalid procedure definition")
            
        accessor, identifier, inputs_str, output_type, operations = match.groups()
        
        inputs = []
        input_symbols = []
        
        if inputs_str.strip():
            for input_param in inputs_str.split(','):
                input_param = input_param.strip()
                if input_param:
                    input_parts = input_param.split()
                    if len(input_parts) >= 2:
                        input_qualifier = input_parts[0]
                        input_id = input_parts[1]
                        inputs.append(input_id)
                        input_symbols.append((input_id, input_qualifier))
        
        old_domain = self.current_domain
        proc_domain = Domain(old_domain, identifier=identifier)
        self.current_domain = proc_domain
        
        for input_id, input_qualifier in input_symbols:
            self.current_domain.bind(input_id, input_id, input_qualifier, "volatile", "ephemeral")
        
        operation_lines = []
        operation_contexts = self._partition_contexts(operations)
        
        for op_context in operation_contexts:
            if op_context.strip():
                translated = self._transmute(op_context)
                if translated:
                    if isinstance(translated, list):
                        for t_line in translated:
                            operation_lines.append(f"    {t_line}")
                    else:
                        operation_lines.append(f"    {translated}")
        
        if self.debug and input_symbols:
            type_checks = []
            for input_id, input_qualifier in input_symbols:
                if input_qualifier in self.QUALIFIERS and input_qualifier != "abstract":
                    type_map = {
                        "numeric": "int, float", 
                        "logical": "bool", 
                        "textual": "str", 
                        "composite": "list, dict, tuple"
                    }
                    py_type = type_map.get(input_qualifier)
                    if py_type:
                        if ',' in py_type:
                            types = py_type.split(', ')
                            check_parts = [f"isinstance({input_id}, {t})" for t in types]
                            check_expr = " or ".join(check_parts)
                            check = f"assert {check_expr}, f\"Qualifier violation: Input {input_id} should be {input_qualifier}, got {{type({input_id}).__name__}}\""
                        else:
                            check = f"assert isinstance({input_id}, {py_type}), f\"Qualifier violation: Input {input_id} should be {input_qualifier}, got {{type({input_id}).__name__}}\""
                        type_checks.append(f"    {check}")
            
            if type_checks:
                operation_lines = type_checks + operation_lines
        
        self.current_domain = old_domain
        
        self.current_domain.register_procedure(identifier, input_symbols, operations, accessor)
        
        func_def = f"def {identifier}({', '.join(inputs)}):"
        
        if output_type:
            operation_lines.insert(0, f'    """{identifier} -> {output_type}"""')
        
        if not operation_lines:
            operation_lines.append("    pass")
            
        result = [func_def] + operation_lines
        
        return "\n".join(result)
    
    def _is_yield(self, context):
        return context.startswith('yield')
    
    def _transmute_yield(self, context):
        match = re.match(r'yield(?:\s+(.*))?', context)
        if not match:
            raise EgoError("Invalid yield statement")
            
        value = match.group(1)
        if value:
            return f"return {value.strip()}"
        else:
            return "return None"
        
    def _is_branch(self, context):
        return context.startswith('when')
        
    def _transmute_branch(self, context):
        match = re.match(r'when\s*\[(.*)\]\s*\{(.*)\}(?:\s*otherwise\s*\{(.*)\})?', context, re.DOTALL)
        if not match:
            raise EgoError("Invalid branch statement syntax")
            
        condition, when_body, otherwise_body = match.groups()
        
        condition = condition.replace('==', '==').replace('!=', '!=')
        condition = condition.replace('&', 'and').replace('|', 'or')
        condition = condition.replace('~=', '!=')
        
        when_lines = []
        when_contexts = self._partition_contexts(when_body)
        for op_context in when_contexts:
            if op_context.strip():
                translated = self._transmute(op_context)
                if translated:
                    if isinstance(translated, list):
                        for t_line in translated:
                            when_lines.append(f"    {t_line}")
                    else:
                        when_lines.append(f"    {translated}")
        
        result = [f"if {condition}:"]
        
        if not when_lines:
            when_lines.append("    pass")
            
        result.extend(when_lines)
        
        if otherwise_body:
            otherwise_lines = []
            otherwise_contexts = self._partition_contexts(otherwise_body)
            for op_context in otherwise_contexts:
                if op_context.strip():
                    translated = self._transmute(op_context)
                    if translated:
                        if isinstance(translated, list):
                            for t_line in translated:
                                otherwise_lines.append(f"    {t_line}")
                        else:
                            otherwise_lines.append(f"    {translated}")
            
            result.append("else:")
            
            if not otherwise_lines:
                otherwise_lines.append("    pass")
                
            result.extend(otherwise_lines)
        
        return result
        
    def _is_iteration(self, context):
        return context.startswith('iterate') or context.startswith('while')
        
    def _transmute_iteration(self, context):
        if context.startswith('iterate'):
            match = re.match(r'iterate\s*\[(.*);(.*);(.*)\]\s*\{(.*)\}', context, re.DOTALL)
            if not match:
                match = re.match(r'iterate\s*\[(.*)\s+over\s+(.*)\]\s*\{(.*)\}', context, re.DOTALL)
                if match:
                    element, collection, body = match.groups()
                    
                    old_domain = self.current_domain
                    iter_domain = Domain(old_domain, identifier="iteration")
                    self.current_domain = iter_domain
                    
                    body_lines = []
                    body_contexts = self._partition_contexts(body)
                    
                    for op_context in body_contexts:
                        if op_context.strip():
                            translated = self._transmute(op_context)
                            if translated:
                                if isinstance(translated, list):
                                    for t_line in translated:
                                        body_lines.append(f"    {t_line}")
                                else:
                                    body_lines.append(f"    {translated}")
                    
                    self.current_domain = old_domain
                    
                    result = [f"for {element} in {collection}:"]
                    
                    if not body_lines:
                        body_lines.append("    pass")
                        
                    result.extend(body_lines)
                    
                    return result
                else:
                    raise EgoError("Invalid iteration syntax")
                
            init, cond, update, body = match.groups()
            
            old_domain = self.current_domain
            iter_domain = Domain(old_domain, identifier="iteration")
            self.current_domain = iter_domain
            
            init_code = self._transmute(init)
            cond_code = cond.strip().replace('&', 'and').replace('|', 'or')
            update_code = self._transmute(update)
            
            body_lines = []
            body_contexts = self._partition_contexts(body)
            
            for op_context in body_contexts:
                if op_context.strip():
                    translated = self._transmute(op_context)
                    if translated:
                        if isinstance(translated, list):
                            for t_line in translated:
                                body_lines.append(f"    {t_line}")
                        else:
                            body_lines.append(f"    {translated}")
            
            if update_code:
                body_lines.append(f"    {update_code}")
            
            self.current_domain = old_domain
            
            result = []
            if init_code:
                result.append(init_code)
            result.append(f"while {cond_code}:")
            
            if not body_lines:
                body_lines.append("    pass")
                
            result.extend(body_lines)
            
            return result
        else:
            match = re.match(r'while\s*\[(.*)\]\s*\{(.*)\}', context, re.DOTALL)
            if not match:
                raise EgoError("Invalid while iteration syntax")
                
            condition, body = match.groups()
            condition = condition.replace('&', 'and').replace('|', 'or')
            
            old_domain = self.current_domain
            iter_domain = Domain(old_domain, identifier="iteration")
            self.current_domain = iter_domain
            
            body_lines = []
            body_contexts = self._partition_contexts(body)
            
            for op_context in body_contexts:
                if op_context.strip():
                    translated = self._transmute(op_context)
                    if translated:
                        if isinstance(translated, list):
                            for t_line in translated:
                                body_lines.append(f"    {t_line}")
                        else:
                            body_lines.append(f"    {translated}")
            
            self.current_domain = old_domain
            
            result = [f"while {condition}:"]
            
            if not body_lines:
                body_lines.append("    pass")
                
            result.extend(body_lines)
            
            return result
    
    def _is_procedure_invoke(self, context):
        return re.match(r'^\w+\s*\[.*\]$', context) is not None
    
    def _transmute_procedure_invoke(self, context):
        match = re.match(r'^(\w+)\s*\[(.*)\]$', context)
        if not match:
            raise EgoError("Invalid procedure invocation syntax")
            
        proc_name, args = match.groups()
        
        proc_info = self.current_domain.resolve_procedure(proc_name)
        if not proc_info and not proc_name in ['emit', 'length', 'numeric', 'logical', 'textual', 'composite']:
            if self.debug:
                return f"# WARNING: Procedure '{proc_name}' not defined in this domain\n{proc_name}({args})"
            return f"{proc_name}({args})"
        
        return f"{proc_name}({args})"
        
    def _is_emit(self, context):
        return context.startswith('emit')
        
    def _transmute_emit(self, context):
        match = re.match(r'emit\s*\[(.*)\]', context)
        if not match:
            raise EgoError("Invalid emit statement")
            
        arg = match.group(1).strip()
        
        args = []
        for a in re.split(r',\s*', arg):
            a = a.strip()
            if not (a.startswith('"') or a.startswith("'") or a.isdigit() or 
                    a in ['True', 'False'] or re.match(r'^\d+\.\d+$', a)):
                var = self.current_domain.resolve(a)
                if not var and not a.startswith('f"'):
                    if self.debug:
                        return f"# WARNING: Symbol '{a}' not bound\nprint({arg})"
            args.append(a)
            
        return f"print({', '.join(args)})"
        
    def _is_transform(self, context):
        return '<-' in context and not self._is_symbol_binding(context) and not self._is_assertion(context)
    
    def _is_assertion(self, context):
        return 'assert' in context and not re.search(r'<-\s*assert', context)
        
    def _transmute_transform(self, context):
        parts = context.split('<-', 1)
        symbol_id = parts[0].strip()
        value = parts[1].strip()
        
        symbol = self.current_domain.resolve(symbol_id)
        if not symbol:
            if self.debug:
                return f"# WARNING: Symbol '{symbol_id}' not bound\n{symbol_id} = {value}"
            else:
                return f"{symbol_id} = {value}"
            
        if not symbol.can_transform():
            raise EgoError(f"Cannot transform permanent symbol '{symbol_id}'")
            
        self.current_domain.transform(symbol_id, value)
        
        return f"{symbol_id} = {value}"
    
    def compile(self, ego_code, output_file):
        machine_code = self.parse(ego_code)
        temp_file = 'temp_ego_code.py'
        
        with open(temp_file, 'w') as f:
            f.write(machine_code)
        
        try:
            py_compile.compile(temp_file, cfile=output_file)
            os.remove(temp_file)
            print(f"Compiled successfully to '{output_file}'")
        except py_compile.PyCompileError as e:
            print(f"Compilation failed: {e}")
            os.remove(temp_file)


compiler = EgoJITCompiler()
sample_code = """





"""
compiler.compile(sample_code, 'pkg_strconfig_sizeof.ego')
